{
    "description": "This is a 8 systolic arrayed gemmini has training convolutions, has max pool, has nonlinear activation, has dw_convs, does not have normalizations, does not have first_layer_optimizations, consists of option BOTH, supports TPU and NVDLA making it robust for any type of dataflow model implementation, it has accumulation type supporting 16 signed integer bits, it has a spatial array output supporting 20 bit Signed integer, Applications: Audio processing pipelines on wearables, Real-time image classification on smartphones",
    "source_code": "package gemmini\n\nimport chisel3._\nimport freechips.rocketchip.config.{Config, Parameters}\nimport freechips.rocketchip.diplomacy.LazyModule\nimport freechips.rocketchip.subsystem._\nimport freechips.rocketchip.tile.{BuildRoCC, OpcodeSet, XLen}\nimport freechips.rocketchip.rocket._\nimport freechips.rocketchip.tile._\nimport freechips.rocketchip.system._\nimport freechips.rocketchip.diplomacy._\n\nimport gemmini.Arithmetic.SIntArithmetic\nimport hardfloat._\n\n// -----------------------\n// Component Mixin Configs\n// -----------------------\n\nobject GemminiConfigs {\n  val defaultConfig = GemminiArrayConfig[SInt, Float, Float](\n    // Datatypes\n    inputType = SInt(8.W),\n    accType = SInt(16.W),\n\n    spatialArrayOutputType = SInt(20.W),\n\n    // Spatial array size options\n    tileRows = 1,\n    tileColumns = 1,\n    meshRows = 8,\n    meshColumns = 8,\n\n    // Spatial array PE options\n    dataflow = Dataflow.BOTH,\n\n    // Scratchpad and accumulator\n    sp_capacity = CapacityInKilobytes(256),\n    acc_capacity = CapacityInKilobytes(64),\n\n    sp_banks = 4,\n    acc_banks = 2,\n\n    sp_singleported = true,\n    acc_singleported = false,\n\n    // DNN options\n    has_training_convs = true,\n    has_max_pool = true,\n    has_nonlinear_activations = true,\n    has_dw_convs =true,\n    has_normalizations = false,\n    has_first_layer_optimizations = false,\n\n    // Reservation station entries\n    reservation_station_entries_ld = 8,\n    reservation_station_entries_st = 4,\n    reservation_station_entries_ex = 16,\n\n    // Ld/Ex/St instruction queue lengths\n    ld_queue_length = 8,\n    st_queue_length = 2,\n    ex_queue_length = 8,\n\n    // DMA options\n    max_in_flight_mem_reqs = 16,\n\n    dma_maxbytes = 64,\n    dma_buswidth = 128,\n\n    // TLB options\n    tlb_size = 4,\n\n    // Mvin and Accumulator scalar multiply options\n    mvin_scale_args = Some(ScaleArguments(\n      (t: SInt, f: Float) => {\n        val f_rec = recFNFromFN(f.expWidth, f.sigWidth, f.bits)\n\n        val in_to_rec_fn = Module(new INToRecFN(t.getWidth, f.expWidth, f.sigWidth))\n        in_to_rec_fn.io.signedIn := true.B\n        in_to_rec_fn.io.in := t.asTypeOf(UInt(t.getWidth.W))\n        in_to_rec_fn.io.roundingMode := consts.round_near_even\n        in_to_rec_fn.io.detectTininess := consts.tininess_afterRounding\n\n        val t_rec = in_to_rec_fn.io.out\n\n        val muladder = Module(new MulAddRecFN(f.expWidth, f.sigWidth))\n        muladder.io.op := 0.U\n        muladder.io.roundingMode := consts.round_near_even\n        muladder.io.detectTininess := consts.tininess_afterRounding\n\n        muladder.io.a := t_rec\n        muladder.io.b := f_rec\n        muladder.io.c := 0.U\n\n        val rec_fn_to_in = Module(new RecFNToIN(f.expWidth, f.sigWidth, t.getWidth))\n        rec_fn_to_in.io.in := muladder.io.out\n        rec_fn_to_in.io.roundingMode := consts.round_near_even\n        rec_fn_to_in.io.signedOut := true.B\n\n        val overflow = rec_fn_to_in.io.intExceptionFlags(1)\n        val maxsat = ((1 << (t.getWidth-1))-1).S\n        val minsat = (-(1 << (t.getWidth-1))).S\n        val sign = rawFloatFromRecFN(f.expWidth, f.sigWidth, rec_fn_to_in.io.in).sign\n        val sat = Mux(sign, minsat, maxsat)\n\n        Mux(overflow, sat, rec_fn_to_in.io.out.asTypeOf(t))\n      },\n      4, Float(8, 24), 4,\n      identity = \"1.0\",\n      c_str = \"({float y = ROUND_NEAR_EVEN((x) * (scale)); y > INT8_MAX ? INT8_MAX : (y < INT8_MIN ? INT8_MIN : (elem_t)y);})\"\n    )),\n\n    mvin_scale_acc_args = None,\n    mvin_scale_shared = false,\n\n    acc_scale_args = Some(ScaleArguments(\n      (t: SInt, f: Float) => {\n        val f_rec = recFNFromFN(f.expWidth, f.sigWidth, f.bits)\n\n        val in_to_rec_fn = Module(new INToRecFN(t.getWidth, f.expWidth, f.sigWidth))\n        in_to_rec_fn.io.signedIn := true.B\n        in_to_rec_fn.io.in := t.asTypeOf(UInt(t.getWidth.W))\n        in_to_rec_fn.io.roundingMode := consts.round_near_even\n        in_to_rec_fn.io.detectTininess := consts.tininess_afterRounding\n\n        val t_rec = in_to_rec_fn.io.out\n\n        val muladder = Module(new MulAddRecFN(f.expWidth, f.sigWidth))\n        muladder.io.op := 0.U\n        muladder.io.roundingMode := consts.round_near_even\n        muladder.io.detectTininess := consts.tininess_afterRounding\n\n        muladder.io.a := t_rec\n        muladder.io.b := f_rec\n        muladder.io.c := 0.U\n\n        val rec_fn_to_in = Module(new RecFNToIN(f.expWidth, f.sigWidth, t.getWidth))\n        rec_fn_to_in.io.in := muladder.io.out\n        rec_fn_to_in.io.roundingMode := consts.round_near_even\n        rec_fn_to_in.io.signedOut := true.B\n\n        val overflow = rec_fn_to_in.io.intExceptionFlags(1)\n        val maxsat = ((1 << (t.getWidth-1))-1).S\n        val minsat = (-(1 << (t.getWidth-1))).S\n        val sign = rawFloatFromRecFN(f.expWidth, f.sigWidth, rec_fn_to_in.io.in).sign\n        val sat = Mux(sign, minsat, maxsat)\n\n        Mux(overflow, sat, rec_fn_to_in.io.out.asTypeOf(t))\n      },\n      8, Float(8, 24), -1,\n      identity = \"1.0\",\n      c_str = \"({float y = ROUND_NEAR_EVEN((x) * (scale)); y > INT8_MAX ? INT8_MAX : (y < INT8_MIN ? INT8_MIN : (acc_t)y);})\"\n    )),\n\n    // SoC counters options\n    num_counter = 8,\n\n    // Scratchpad and Accumulator input/output options\n    acc_read_full_width = true,\n    acc_read_small_width = true,\n\n    ex_read_from_spad = true,\n    ex_read_from_acc = true,\n    ex_write_to_spad = true,\n    ex_write_to_acc = true,\n  )\n}\n\n/**\n * Mixin which sets the default parameters for a systolic array accelerator.\n   Also sets the system bus width to 128 bits (instead of the deafult 64 bits) to\n   allow for the default 16x16 8-bit systolic array to be attached.\n */\nclass DefaultGemminiConfig[T <: Data : Arithmetic, U <: Data, V <: Data](\n  gemminiConfig: GemminiArrayConfig[T,U,V] = GemminiConfigs.defaultConfig\n) extends Config((site, here, up) => {\n  case BuildRoCC => up(BuildRoCC) ++ Seq(\n    (p: Parameters) => {\n      implicit val q = p\n      val gemmini = LazyModule(new Gemmini(gemminiConfig))\n      gemmini\n    }\n  )\n})"
}